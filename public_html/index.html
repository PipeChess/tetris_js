<!DOCTYPE html>
<!--
To change this license header, choose License Headers in Project Properties.
To change this template file, choose Tools | Templates
and open the template in the editor.
-->
<html>
    <head>
        <title>TETRIS js</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
    </head>
    <body onkeydown="keyPress(event);">
        <canvas id="game" height="440" width="200"></canvas>
    </body>
</html>

<script>
    var gmatrix;
    var size_height = 22;
    var size_width = 10;
    var speed = 1;
    var currentBlock = null;

    var canvas = document.getElementById("game");
    var ctx = canvas.getContext("2d");


    var blocks = [{
            coords: [[-2, 4], [-2, 5], [-1, 4], [-1, 5]],
            color: 'red',
            pivot: null,
            name: 'cube'
        }, {
            coords: [[-3, 4], [-2, 4], [-1, 4], [-1, 3]],
            color: 'yellow',
            pivot: 1,
            name: 'l_shape_left'
        }, {
            coords: [[-3, 4], [-2, 4], [-1, 4], [-1, 5]],
            color: 'orange',
            pivot: 1,
            name: 'l_shape_right'
        }, {
            coords: [[-3, 4], [-2, 4], [-2, 5], [-1, 5]],
            color: 'olive',
            pivot: 1,
            name: 's_shape_left'
        }, {
            coords: [[-3, 5], [-2, 5], [-2, 4], [-1, 4]],
            color: 'lilac',
            pivot: 1,
            name: 's_shape_right'
        }, {
            coords: [[-4, 4], [-3, 4], [-2, 4], [-1, 4]],
            color: 'white',
            pivot: 1,
            name: 'bar'
        }];

    initializeGameMatrix();
    newRandomBlock();
    updateBlockPosition('down');


    /**
     * Based on direction either moves the block left, right, down or performs
     * a 2D rotation & and updates the current block with the new coordinates
     * @param string dir
     * @returns void
     */
    function updateBlockPosition(dir, clockwise) {
        for (var i = 0; i < currentBlock.coords.length; i++) {
            switch (dir) {
                case 'down':
                    currentBlock.coords[i][0] += 1;
                    break;

                case 'left':
                    if (currentBlock.coords[i][1] > 0) {
                        currentBlock.coords[i][1] -= 1;
                    }
                    break;

                case 'right':
                    if (currentBlock.coords[i][1] < size_width - 1) {
                        currentBlock.coords[i][1] += 1;
                    }
                    break;

                case 'turn':
                    if (currentBlock.pivot == null) {
                        break;
                    }
                    var angle = clockwise ? -80 : 80;
                    for (var i = 0; i < currentBlock.coords.length; i++) {
                        if (i != currentBlock.pivot) {
                            var op_x = currentBlock.coords[i][1];
                            var op_y = currentBlock.coords[i][0];

                            var c_x = currentBlock.coords[currentBlock.pivot][1];
                            var c_y = currentBlock.coords[currentBlock.pivot][0];

                            var px = Math.round(Math.cos(angle) * (op_x - c_x) - Math.sin(angle) * (op_y - c_y) + c_x);
                            var py = Math.round(Math.sin(angle) * (op_x - c_x) - Math.cos(angle) * (op_y - c_y) + c_y);

                            currentBlock.coords[i][1] = px;
                            currentBlock.coords[i][0] = py;
                        }
                    }
                    break;
            }
        }
        setBlock();
    }

    /**
     * Calls reset and sets newly updated block on display array if within
     * game area
     * @returns void
     */
    function setBlock() {
        resetGameMatrix();
        for (var i = 0; i < currentBlock.coords.length; i++) {
            var x = currentBlock.coords[i][0];
            var y = currentBlock.coords[i][1];
            if (x >= 0 && y >= 0) {
                gmatrix[x][y] = 1;
            }
        }
        drawDisplay();
    }

    /**
     * Clear the display redraws background, all updated blocks and fills them
     * @returns void
     */
    function drawDisplay() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.rect(0, 0, 440, 500);
        ctx.fillStyle = "aqua";
        ctx.fill();
        ctx.beginPath();
        for (var i = 0; i < gmatrix.length; i++) {
            for (var j = 0; j < gmatrix[i].length; j++) {
                if (gmatrix[i][j] == true) {
                    var x = j * 20;
                    var y = i * 20;
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + 20, y);
                    ctx.moveTo(x + 20, y);
                    ctx.lineTo(x + 20, y + 20);
                    ctx.moveTo(x + 20, y + 20);
                    ctx.lineTo(x, y + 20);
                    ctx.moveTo(x, y + 20);
                    ctx.lineTo(x, y);

                    //fill color
                    ctx.rect(x, y, 20, 20);
                    ctx.fillStyle = currentBlock.color;
                    ctx.fill();

                    //draw borders
                    ctx.stroke();
                }
            }
        }
    }

    /**
     * Resets all no-fixed array positions back to false/empty 
     * @returns void
     */
    function resetGameMatrix() {
        for (var i = 0; i < gmatrix.length; i++) {
            for (var j = 0; j < gmatrix[i].length; j++) {
                if (gmatrix[i][j] !== true) {
                    gmatrix[i][j] = false;
                }
            }
        }
    }

    /**
     * Initializes a 22 x 10 array and sets all positons to false/empty
     * @returns void
     */
    function initializeGameMatrix() {
        gmatrix = new Array(size_height);
        for (var i = 0; i < gmatrix.length; i++) {
            gmatrix[i] = new Array(size_width);
            for (var j = 0; j < gmatrix[i].length; j++) {
                gmatrix[i][j] = false;
            }
        }
    }

    /**
     * Command function for movement of blocks
     * @param event ev
     * @returns void
     */
    function keyPress(ev) {
        var key = ev.which || ev.keyCode;
        switch (key) {
            case 37:
                updateBlockPosition('left');
                break;

            case 40:
                updateBlockPosition('down');
                break;

            case 39:
                updateBlockPosition('right');
                break;

            case 17:
                updateBlockPosition('turn', false);
                break;

            case 18:
                updateBlockPosition('turn', true);
                break;

            default:
                break;
        }
    }

    /**
     * Sets a new random block
     * @returns void
     */
    function newRandomBlock() {
        var rand = Math.floor((Math.random() * 100)) % blocks.length;
        currentBlock = blocks[rand];
    }
</script>
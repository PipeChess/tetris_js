<!DOCTYPE html>
<html>
    <head>
        <title>TETRIS js</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style>
            body {
                background: #123456;
                font-family: Arial;
                color: white
            }

            .center {
                margin: auto;
                width: 50%;
                padding: 10px;
            }
        </style>
    </head>
    <body onkeydown="keyPress(event);">
        <div class="center">
            <span id="score">0</span> points 
            level <span id="level">1</span>
            <span id="info"></span>
            <br />
            <button id="startGameBtn" onclick="startRoutine(true);">new game</button>
            <button id="endGameBtn" onclick="endGame(false);">end game</button>
            <button id="pauseGameBtn" onclick="pauseGame();">pause</button>
            <br />
            <br />
            <canvas id="game" height="440" width="200"></canvas>
            <br />
            <span id="gameMessage"></span>
        </div>
    </body>
</html>

<script>
    var gmatrix;
    var size_height = 22;
    var size_width = 10;
    var speed = 1;
    var gameInterval = null;
    var currentBlock = null;
    var upcomingBlock = null;
    var initialSpeed = 1000;
    var enabledCommands = false;
    var totalPoints = 0;
    var gamePaused = false;
    var canvas = document.getElementById("game");
    var ctx = canvas.getContext("2d");
    var blocks = [{
            coords: [[-2, 4], [-2, 5], [-1, 4], [-1, 5]],
            color: 'yellow',
            pivot: null,
            name: 'O-block'
        }, {
            coords: [[-3, 4], [-2, 4], [-1, 4], [-1, 3]],
            color: 'blue',
            pivot: 1,
            name: 'J-block'
        }, {
            coords: [[-3, 4], [-2, 4], [-1, 4], [-1, 5]],
            color: 'orange',
            pivot: 1,
            name: 'L-Block'
        }, {
            coords: [[-3, 4], [-2, 4], [-2, 5], [-1, 5]],
            color: 'green',
            pivot: 1,
            name: 'S-Block'
        }, {
            coords: [[-3, 5], [-2, 5], [-2, 4], [-1, 4]],
            color: 'red',
            pivot: 1,
            name: 'Z-Block'
        }, {
            coords: [[-4, 4], [-3, 4], [-2, 4], [-1, 4]],
            color: 'cyan',
            pivot: 1,
            name: 'I-Block'
        }, {
            coords: [[-2, 5], [-1, 4], [-1, 5], [-1, 6]],
            color: 'purple',
            pivot: 2,
            name: 'T-Block'
        }];

    startRoutine(true);

    /**
     * Start routine to initialize game matrix, interval & commands.
     * Generates a new block & triggers update event
     * @param boolean newgame
     * @returns void
     */
    function startRoutine(newgame) {
        if (newgame && gameInterval === null) {
            enabledCommands = true;
            initializeGameMatrix();
            gameInterval = setInterval(function () {
                updateBlockPosition('down');
            }, initialSpeed);
        }
        newRandomBlock();
        updateBlockPosition('down');
    }

    /**
     * Ends game interval resets game matrix disables commands
     * @param boolean lost
     * @returns viod
     */
    function endGame(lost) {
        if (lost) {
            document.getElementById("gameMessage").innerHTML = "YOU LOST";
        }
        clearInterval(gameInterval);
        gameInterval = null;
        initializeGameMatrix();
        drawDisplay();
        enabledCommands = false;
    }

    /**
     * Either pauses or un-pauses game. Blocks or allows commands, either clears
     * or reinitiates game interval
     * @returns void
     */
    function pauseGame() {
        if (gamePaused) {
            enabledCommands = true;
            gameInterval = setInterval(function () {
                updateBlockPosition('down');
            }, initialSpeed);
            gamePaused = false;
            document.getElementById("pauseGameBtn").innerHTML = "pause";
        } else {
            gamePaused = true;
            clearInterval(gameInterval);
            gameInterval = null;
            enabledCommands = false;
            document.getElementById("pauseGameBtn").innerHTML = "resume";
        }
    }

    /**
     * Based on direction either moves the block left, right, down or performs
     * a 2D rotation & and updates the current block with the new coordinates
     * @param string dir
     * @returns void
     */
    function updateBlockPosition(dir, clockwise) {
        var tmpBlock = JSON.parse(JSON.stringify(currentBlock));
        for (var i = 0; i < tmpBlock.coords.length; i++) {
            switch (dir) {
                case 'down':
                    tmpBlock.coords[i][0] += 1;
                    break;
                case 'left':
                    tmpBlock.coords[i][1] -= 1;
                    break;
                case 'right':
                    tmpBlock.coords[i][1] += 1;
                    break;
                case 'turn':
                    if (tmpBlock.pivot == null) {
                        break;
                    }
                    var angle = clockwise ? -80 : 80;
                    for (var i = 0; i < tmpBlock.coords.length; i++) {
                        if (i != tmpBlock.pivot) {
                            var op_x = tmpBlock.coords[i][1];
                            var op_y = tmpBlock.coords[i][0];
                            var c_x = tmpBlock.coords[tmpBlock.pivot][1];
                            var c_y = tmpBlock.coords[tmpBlock.pivot][0];
                            var px = Math.round(Math.cos(angle) * (op_x - c_x) - Math.sin(angle) * (op_y - c_y) + c_x);
                            var py = Math.round(Math.sin(angle) * (op_x - c_x) - Math.cos(angle) * (op_y - c_y) + c_y);
                            tmpBlock.coords[i][1] = px;
                            tmpBlock.coords[i][0] = py;
                        }
                    }
                    break;
            }
        }
        checkBlock(tmpBlock, dir);
    }

    /**
     * Routine to check if rows are completed, removing them and creating new top
     * row, after calculating all completed rows calls score. 
     * @returns void
     */
    function checkGameMatrixForRowCompletion() {
        var rowsRemoved = 0;
        for (var i = 0; i < gmatrix.length; i++) {
            var row = true;
            for (var j = 0; j < gmatrix[i].length; j++) {
                if (typeof gmatrix[i][j] !== 'object') {
                    row = false;
                }
            }
            if (row) {
                for (var m = i; m >= 0; m--) {
                    if (m == 0) {
                        for (var n = 0; n < gmatrix[0].length; n++) {
                            gmatrix[0][n] = false;
                        }
                    } else {
                        gmatrix[m] = JSON.parse(JSON.stringify(gmatrix[m - 1]));
                    }
                }
                rowsRemoved++;
            }
        }
        score(rowsRemoved);
    }

    /**
     * Based on user input, decides if tmp block either exceeds game are boundaries
     * or overlaps with other placed blocks. If so the move will be ignore, otherwise
     * the block gets either placed or if after placement the currentblock is not totally
     * within game area, the game will be ended.
     * @param blockObject tmpBlock
     * @param direction dir
     * @returns void
     */

    function checkBlock(tmpBlock, dir) {
        for (var i = 0; i < tmpBlock.coords.length; i++) {
            if (tmpBlock.coords[i][0] >= 0) {
                //reached left or right edge of game area
                if (tmpBlock.coords[i][1] < 0 || tmpBlock.coords[i][1] > size_width - 1) {
                    return;
                }
                //reached bottom of game area
                if (tmpBlock.coords[i][0] > size_height - 1) {
                    setCurrentBlockFixed();
                    return;
                }
                //collision with other blocks
                if (typeof gmatrix[tmpBlock.coords[i][0]][tmpBlock.coords[i][1]] === 'object') {
                    if (dir === 'down') {
                        for (var m = 0; m < currentBlock.coords.length; m++) {
                            for (var n = 0; n < currentBlock.coords[m].length; n++) {
                                if (currentBlock.coords[m][0] < 0) {
                                    endGame(true);
                                    return;
                                }
                            }
                        }
                        setCurrentBlockFixed();
                    }
                    return;
                }
            }
        }
        currentBlock = tmpBlock;
        setBlock();
    }

    /**
     * Sets a block fixed by adding it to the game area (display matrix)
     * @returns  void
     */
    function setCurrentBlockFixed() {
        for (var i = 0; i < currentBlock.coords.length; i++) {
            gmatrix[currentBlock.coords[i][0]][currentBlock.coords[i][1]] = currentBlock;
        }
        checkGameMatrixForRowCompletion();
        startRoutine(false);
    }

    /**
     * Calls reset and sets newly updated block on display array if within
     * game area
     * @returns void
     */
    function setBlock() {
        resetGameMatrix();
        for (var i = 0; i < currentBlock.coords.length; i++) {
            var x = currentBlock.coords[i][0];
            var y = currentBlock.coords[i][1];
            if (x >= 0 && y >= 0) {
                gmatrix[x][y] = 1;
            }
        }
        drawDisplay();
    }

    /**
     * Adds to score if rows where removed. Adjusts the game level based on score
     * 
     * @param int rowAmount
     * @returns void
     */
    function score(rowAmount) {
        switch (rowAmount) {
            case 1:
                totalPoints += 10;
                break;

            case 2:
                totalPoints += 40;
                break;

            case 3:
                totalPoints += 80;
                break;

            case 4:
                totalPoints += 150;
                break;
        }
        document.getElementById("score").innerHTML = totalPoints;

        var speedVal = Math.round(totalPoints / 100);
        initialSpeed = (speedVal > 1 ? 1000 - (speedVal * 50) : 1000);
        document.getElementById("level").innerHTML = speedVal + 1
    }

    /**
     * Clear the display redraws background, all updated blocks and fills them
     * @returns void
     */
    function drawDisplay() {
        document.getElementById("info").innerHTML = "next block: " + upcomingBlock.name;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.beginPath();
        ctx.rect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "beige";
        ctx.fill();
        ctx.strokeStyle = "#000";
        ctx.strokeRect(0, 0, canvas.width, canvas.height);
        for (var i = 0; i < gmatrix.length; i++) {
            for (var j = 0; j < gmatrix[i].length; j++) {
                if (gmatrix[i][j] !== false) {
                    var color;
                    if (gmatrix[i][j] === 1) {
                        color = currentBlock.color;
                    } else {
                        color = gmatrix[i][j].color;
                    }
                    var x = j * 20;
                    var y = i * 20;
                    ctx.beginPath();
                    ctx.strokeStyle = "#000";
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + 20, y);
                    ctx.moveTo(x + 20, y);
                    ctx.lineTo(x + 20, y + 20);
                    ctx.moveTo(x + 20, y + 20);
                    ctx.lineTo(x, y + 20);
                    ctx.moveTo(x, y + 20);
                    ctx.lineTo(x, y);
                    //draw borders
                    ctx.stroke();
                    //fill color
                    ctx.rect(x, y, 20, 20);
                    ctx.fillStyle = color;
                    ctx.fill();
                }
            }
        }


    }

    /**
     * Resets all no-fixed array positions back to false/empty 
     * @returns void
     */
    function resetGameMatrix() {
        for (var i = 0; i < gmatrix.length; i++) {
            for (var j = 0; j < gmatrix[i].length; j++) {
                if (typeof gmatrix[i][j] !== 'object') {
                    gmatrix[i][j] = false;
                }
            }
        }
    }

    /**
     * Initializes a 22 x 10 array and sets all positons to false/empty
     * @returns void
     */
    function initializeGameMatrix() {
        gmatrix = new Array(size_height);
        for (var i = 0; i < gmatrix.length; i++) {
            gmatrix[i] = new Array(size_width);
            for (var j = 0; j < gmatrix[i].length; j++) {
                gmatrix[i][j] = false;
            }
        }
    }

    /**
     * Command function for movement of blocks
     * @param event ev
     * @returns void
     */
    function keyPress(ev) {
        var key = ev.which || ev.keyCode;
        if (enabledCommands) {
            switch (key) {
                case 37:
                    updateBlockPosition('left');
                    break;
                case 40:
                    updateBlockPosition('down');
                    break;
                case 39:
                    updateBlockPosition('right');
                    break;
                case 16:
                    updateBlockPosition('turn', false);
                    break;
                case 17:
                    updateBlockPosition('turn', true);
                    break;
                default:
                    break;
            }
        }
        switch (key) {
            case 32:
                pauseGame();
                break;
            default:
                break;

        }
    }

    /**
     * Sets a new random block
     * @returns void
     */
    function newRandomBlock() {
        currentBlock = (upcomingBlock ? upcomingBlock : blocks[Math.floor((Math.random() * 60)) % 7]);
        upcomingBlock = blocks[Math.floor((Math.random() * 60)) % 7];
    }

</script>
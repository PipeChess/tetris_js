<!DOCTYPE html>
<!--
To change this license header, choose License Headers in Project Properties.
To change this template file, choose Tools | Templates
and open the template in the editor.
-->
<html>
    <head>
        <title>TETRIS js</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
    </head>
    <body onkeydown="keyPress(event);">
        <span id="score">0</span> points 
        <button id="startGameBtn" onclick="startRoutine(true);">new game</button>
        <button id="startGameBtn" onclick="endGame(false);">end game</button>
        <br />
        <br />
        <canvas id="game" height="440" width="200"></canvas>
        <br />
        <span id="gameMessage"></span>
    </body>
</html>

<script>
    var gmatrix;
    var size_height = 22;
    var size_width = 10;
    var speed = 1;
    var gameInterval = null;
    var currentBlock = null;
    var initialSpeed = 1000;
    var enabledCommands = false;
    var totalPoints = 0;

    var canvas = document.getElementById("game");
    var ctx = canvas.getContext("2d");

    var blocks = [{
            coords: [[-2, 4], [-2, 5], [-1, 4], [-1, 5]],
            color: 'red',
            pivot: null,
            name: 'cube'
        }, {
            coords: [[-3, 4], [-2, 4], [-1, 4], [-1, 3]],
            color: 'yellow',
            pivot: 1,
            name: 'l_shape_left'
        }, {
            coords: [[-3, 4], [-2, 4], [-1, 4], [-1, 5]],
            color: 'orange',
            pivot: 1,
            name: 'l_shape_right'
        }, {
            coords: [[-3, 4], [-2, 4], [-2, 5], [-1, 5]],
            color: 'olive',
            pivot: 1,
            name: 's_shape_left'
        }, {
            coords: [[-3, 5], [-2, 5], [-2, 4], [-1, 4]],
            color: 'brown',
            pivot: 1,
            name: 's_shape_right'
        }, {
            coords: [[-4, 4], [-3, 4], [-2, 4], [-1, 4]],
            color: 'white',
            pivot: 1,
            name: 'bar'
        }, {
            coords: [[-2, 5], [-1, 4], [-1, 5], [-1, 6]],
            color: 'pink',
            pivot: 2,
            name: 'camel'
        }];

    startRoutine(true);

    function startRoutine(newgame) {
        if (newgame && gameInterval === null) {
            enabledCommands = true;
            initializeGameMatrix();
            gameInterval = setInterval(function () {
                updateBlockPosition('down');
            }, initialSpeed);
        }
        newRandomBlock();
        updateBlockPosition('down');
    }

    function endGame(lost) {
        if (lost) {
            document.getElementById("gameMessage").innerHTML = "YOU LOST";
        }
        clearInterval(gameInterval);
        gameInterval = null;
        initializeGameMatrix();
        drawDisplay();
        enabledCommands = false;
    }

    /**
     * Based on direction either moves the block left, right, down or performs
     * a 2D rotation & and updates the current block with the new coordinates
     * @param string dir
     * @returns void
     */
    function updateBlockPosition(dir, clockwise) {
        var tmpBlock = JSON.parse(JSON.stringify(currentBlock));
        for (var i = 0; i < tmpBlock.coords.length; i++) {
            switch (dir) {
                case 'down':
                    tmpBlock.coords[i][0] += 1;
                    break;
                case 'left':
                    tmpBlock.coords[i][1] -= 1;
                    break;
                case 'right':
                    tmpBlock.coords[i][1] += 1;
                    break;
                case 'turn':
                    if (tmpBlock.pivot == null) {
                        break;
                    }
                    var angle = clockwise ? -80 : 80;
                    for (var i = 0; i < tmpBlock.coords.length; i++) {
                        if (i != tmpBlock.pivot) {
                            var op_x = tmpBlock.coords[i][1];
                            var op_y = tmpBlock.coords[i][0];
                            var c_x = tmpBlock.coords[tmpBlock.pivot][1];
                            var c_y = tmpBlock.coords[tmpBlock.pivot][0];
                            var px = Math.round(Math.cos(angle) * (op_x - c_x) - Math.sin(angle) * (op_y - c_y) + c_x);
                            var py = Math.round(Math.sin(angle) * (op_x - c_x) - Math.cos(angle) * (op_y - c_y) + c_y);
                            tmpBlock.coords[i][1] = px;
                            tmpBlock.coords[i][0] = py;
                        }
                    }
                    break;
            }
        }
        checkBlock(tmpBlock, dir);
    }

    function checkGameMatrixForRowCompletion() {
        var rowsRemoved = 0;
        for (var i = 0; i < gmatrix.length; i++) {
            var row = true;
            for (var j = 0; j < gmatrix[i].length; j++) {
                if (typeof gmatrix[i][j] !== 'object') {
                    row = false;
                }
            }
            if (row) {
                for (var m = i; m >= 0; m--) {
                    if (m == 0) {
                        for (var n = 0; n < gmatrix[0].length; n++) {
                            gmatrix[0][n] = false;
                        }
                    } else {
                        gmatrix[m] = JSON.parse(JSON.stringify(gmatrix[m - 1]));
                    }
                }
                rowsRemoved++;
            }
        }
        score(rowsRemoved);
    }

    function checkBlock(tmpBlock, dir) {
        for (var i = 0; i < tmpBlock.coords.length; i++) {
            if (tmpBlock.coords[i][0] >= 0) {
                //reached left or right edge of game area
                if (tmpBlock.coords[i][1] < 0 || tmpBlock.coords[i][1] > size_width - 1) {
                    return;
                }
                //reached bottom of game area
                if (tmpBlock.coords[i][0] > size_height - 1) {
                    setCurrentBlockFixed();
                    return;
                }
                //collision with other blocks
                if (typeof gmatrix[tmpBlock.coords[i][0]][tmpBlock.coords[i][1]] === 'object') {
                    if (dir === 'down') {
                        for (var m = 0; m < tmpBlock.coords.length; m++) {
                            for (var n = 0; n < tmpBlock.coords[m].length; n++) {
                                if (tmpBlock.coords[m][0] < 0) {
                                    endGame(true);
                                    return;
                                }
                            }
                        }
                        setCurrentBlockFixed();
                    }
                    return;
                }
            }
        }
        currentBlock = tmpBlock;
        setBlock();
    }

    function setCurrentBlockFixed() {
        for (var i = 0; i < currentBlock.coords.length; i++) {
            gmatrix[currentBlock.coords[i][0]][currentBlock.coords[i][1]] = currentBlock;
        }
        checkGameMatrixForRowCompletion();
        startRoutine(false);
    }

    /**
     * Calls reset and sets newly updated block on display array if within
     * game area
     * @returns void
     */
    function setBlock() {
        resetGameMatrix();
        for (var i = 0; i < currentBlock.coords.length; i++) {
            var x = currentBlock.coords[i][0];
            var y = currentBlock.coords[i][1];
            if (x >= 0 && y >= 0) {
                gmatrix[x][y] = 1;
            }
        }
        drawDisplay();
    }

    function score(rowAmount) {
        switch (rowAmount) {
            case 1:
                totalPoints += 10;
                break;

            case 2:
                totalPoints += 40;
                break;

            case 3:
                totalPoints += 80;
                break;

            case 4:
                totalPoints += 150;
                break;
        }
        document.getElementById("score").innerHTML = totalPoints;
    }

    /**
     * Clear the display redraws background, all updated blocks and fills them
     * @returns void
     */
    function drawDisplay() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.beginPath();
        ctx.rect(0, 0, 440, 500);
        ctx.fillStyle = "aqua";
        ctx.fill();
        for (var i = 0; i < gmatrix.length; i++) {
            for (var j = 0; j < gmatrix[i].length; j++) {
                if (gmatrix[i][j] !== false) {
                    var color;
                    if (gmatrix[i][j] === 1) {
                        color = currentBlock.color;
                    } else {
                        color = gmatrix[i][j].color;
                    }
                    var x = j * 20;
                    var y = i * 20;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + 20, y);
                    ctx.moveTo(x + 20, y);
                    ctx.lineTo(x + 20, y + 20);
                    ctx.moveTo(x + 20, y + 20);
                    ctx.lineTo(x, y + 20);
                    ctx.moveTo(x, y + 20);
                    ctx.lineTo(x, y);
                    //draw borders
                    ctx.stroke();
                    //fill color
                    ctx.rect(x, y, 20, 20);
                    ctx.fillStyle = color;
                    ctx.fill();
                }
            }
        }
    }

    /**
     * Resets all no-fixed array positions back to false/empty 
     * @returns void
     */
    function resetGameMatrix() {
        for (var i = 0; i < gmatrix.length; i++) {
            for (var j = 0; j < gmatrix[i].length; j++) {
                if (typeof gmatrix[i][j] !== 'object') {
                    gmatrix[i][j] = false;
                }
            }
        }
    }

    /**
     * Initializes a 22 x 10 array and sets all positons to false/empty
     * @returns void
     */
    function initializeGameMatrix() {
        gmatrix = new Array(size_height);
        for (var i = 0; i < gmatrix.length; i++) {
            gmatrix[i] = new Array(size_width);
            for (var j = 0; j < gmatrix[i].length; j++) {
                gmatrix[i][j] = false;
            }
        }
    }

    /**
     * Command function for movement of blocks
     * @param event ev
     * @returns void
     */
    function keyPress(ev) {
        if (enabledCommands) {
            var key = ev.which || ev.keyCode;
            switch (key) {
                case 37:
                    updateBlockPosition('left');
                    break;
                case 40:
                    updateBlockPosition('down');
                    break;
                case 39:
                    updateBlockPosition('right');
                    break;
                case 17:
                    updateBlockPosition('turn', false);
                    break;
                case 18:
                    updateBlockPosition('turn', true);
                    break;
                default:
                    break;
            }
        }
    }

    /**
     * Sets a new random block
     * @returns void
     */
    function newRandomBlock() {
        var rand = Math.floor((Math.random() * 100)) % 5;
        currentBlock = blocks[rand];
    }

</script>